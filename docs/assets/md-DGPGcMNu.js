import{b as n,o,w as u,g as e,B as l,v as i,x as c,C as r}from"./modules/vue-CN_MgJgD.js";import{I as d}from"./slidev/default-BumIh_6H.js";import{u as f,f as p}from"./slidev/context-CVmnFa33.js";import"./index-CdRH_Vka.js";import"./modules/shiki-CbJNJzfY.js";const w={__name:"thread_local.md__slidev_20",setup(m){const{$clicksContext:t,$frontmatter:s}=f();return t.setup(),(g,a)=>(o(),n(d,i(c(r(p)(r(s),19))),{default:u(()=>a[0]||(a[0]=[e("h1",null,"Takeaways",-1),e("br",null,null,-1),l(" 1. Prefer being explicit - use `static thread_local` "),e("ol",{start:"2"},[e("li",null,[e("p",null,[e("strong",null,[l("Lifetime of "),e("code",null,"thread_local"),l(" scalar types:")]),l(" valid from the beginning till the end of the thread.")])]),e("li",null,[e("p",null,[e("strong",null,[l("Lifetime of "),e("code",null,"thread_local"),l(" objects:")])]),e("ul",null,[e("li",null,[e("strong",null,"Construction"),l(": Occurs before the first use, but no guarantees when exactly.")]),e("li",null,[e("strong",null,"Destruction"),l(": Happens before regular static variables are destroyed. There are workarounds.")])])]),e("li",null,[e("p",null,[e("strong",null,[l("Performance of "),e("code",null,"thread_local"),l(":")])]),e("ul",null,[e("li",null,[e("strong",null,"In executables"),l(": accessing "),e("code",null,"thread_local"),l(" variables is as fast as accessing regular variables.")]),e("li",null,[e("strong",null,"In shared objects"),l(": "),e("code",null,"thread_local"),l(" access is approximately "),e("strong",null,"3x slower"),l("."),e("br"),l(" If a variable access is in a performance-critical path, there is a workaround in some cases.")])])])],-1)])),_:1},16))}};export{w as default};
